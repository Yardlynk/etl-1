module ETL::BatchFactory
  class Base
    include Enumerable

    # Generates an empty Batch class
    def generate
      return ETL::Batch.new
    end
    
    # Parses batch from string representation. Supported formats:
    #   * key1=value1[;keyN=valueN]+
    #   * JSON
    # Raises an exception if unable to parse
    # Does *not* perform validation on the batch
    def parse!(str)
      # be stringent about parsing the key=value format
      key = '\w+'
      value = '\w[-:\w]*'
      key_value = "#{key}=#{value}"
      h = 
        if str.empty? 
          {}
        elsif str =~ /^#{key_value}(;#{key_value})*$/
          str.split(/;/).each_with_object({}) do |kv, hsh|
            kv.match(/(#{key})=(#{value})/) do |md|
              hsh[md[1]] = md[2]
            end
          end
        else
          # pass everything else to JSON parser to deal with
          begin
            JSON.parse(str) # will throw exception on error
          rescue StandardError => ex
            raise ETL::BatchError, ex # remap to our exception type
          end
        end
      
      from_hash(ETL::HashUtil::symbolize_keys(h))
    end
    
    # Similar to parse! but only returns nil if unable to parse
    def parse(str)
      parse!(str)
    rescue
      nil
    end
    
    # Creates a ETL::Batch object from a hash. Typically we can just feed this
    # into the batch constructor but maybe derived classes want to do something
    # fancier with this.
    def from_hash(h)
      ETL::Batch.new(h)
    end
    
    # Performs validation on the specified batch and throws an exception if
    # it does not contain the correct data to run a job. 
    def validate!(batch)
      # by default we want strict behavior so that we don't get extraneous 
      # keys in the batch that aren't getting used. 
      unless batch.to_h.empty?
        raise ETL::BatchError, "Invalid batch #{batch.to_h} specified; expected empty"
      end
      batch
    end
    
    # The same as validate!(batch) but doesn't throw an exception. Returns
    # nil if the batch is not valid
    def validate(batch)
      validate!(batch)
    rescue ETL::BatchError => ex
      ETL.logger.exception(ex, Logger::DEBUG) # don't lose the message!
      nil
    end
    
    # Use this to iterate over all batches generated by this factory. By 
    # default we assume there's only one batch. Derived classes can
    def each(&block)
      batches = generate
      if batches.respond_to?(:each) # array of Batch
        batches.each do |b|
          yield b
        end
      else # single Batch
        yield batches
      end
    end
  end
  
  class Null < Base
  end
end
